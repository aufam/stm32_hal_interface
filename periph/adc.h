#ifndef PERIPH_ADC_H
#define PERIPH_ADC_H

#include "main.h"
#ifdef HAL_ADC_MODULE_ENABLED

#include "periph/config.h"
#include "Core/Inc/adc.h"
#include "etl/array.h"
#include "etl/function.h"

namespace Project::periph {

    /// ADC peripheral class
    /// @note requirements: 
    ///     - DMA circular
    ///     - DMA continuous request
    struct ADCD {
        using Callback = etl::Function<void(), void*>;
        using CallbackList = detail::UniqueInstances<Callback, PERIPH_CALLBACK_LIST_MAX_SIZE>
        inline static detail::UniqueInstances<ADCD*, 3> Instances;
        static const size_t N_CHANNEL = PERIPH_ADC_N_CHANNEL;

        ADC_HandleTypeDef &hadc;                    ///< ADC handler generated by cubeMX
        etl::Array<uint32_t, N_CHANNEL> buf = {};   ///< ADC buffer
        CallbackList callbackList = {};             ///< list of ADC complete callback functions

        ADCD(const ADCD&) = delete;             ///< disable copy constructor
        ADCD& operator=(const ADCD&) = delete;  ///< disable copy assignment

        /// start ADC DMA circular
        void init() {
            HAL_ADC_Start_DMA(&hadc, buf.begin(), N_CHANNEL);
            __HAL_DMA_DISABLE_IT(hadc.DMA_Handle, DMA_IT_HT); // disable half complete
            Instances.push(this);
        }

        /// stop ADC DMA circular and reset callback
        void deinit() { 
            if (callbackList.isEmpty()) {
                HAL_ADC_Stop_DMA(&hadc); 
                Instances.pop(this);
            }
        }

        /// get ADC raw value given the index
        uint32_t operator[](int index) { return buf[index]; }

        /// get ADC voltage value given the index
        float operator()(int index) { return float(buf[index]) * float(PERIPH_ADC_VREF) / float(1 << PERIPH_ADC_RESOLUTION_BITS); }
    };
} // namespace Project

#endif // HAL_ADC_MODULE_ENABLED
#endif // PERIPH_ADC_H